int set_cell(global const int * mat, int rows,
						 int cols, int m_cols, int m_rows, int cell)
						 {

							 int cont=0;
							 int start_rows = -1;
							 int start_cols = -1;
							 int end_rows = 2;
							 int end_cols = 2;

							 if(m_rows == 0){
								 start_rows = 0;
							 }
							 if(m_cols == 0){
								 start_cols = 0;
							 }
							 if(m_rows == rows - 1){
								 end_rows = 1;
							 }
							 if(m_cols == cols - 1){
								 end_cols = 1;
							 }

							 for(int i = start_rows; i < end_rows; i++){
								 for(int j = start_cols; j < end_cols; j++){
									 	if(i == 0 && j == 0){
											continue;
										}
										 if(mat[((m_rows + i)*cols) + (m_cols + j)] == 1){
											 cont++;
										 }
								 }
							 }

							 /*#ifdef __llvm__
							 #pragma GCC diagnostic ignored "-Wdangling-else"
							 if(m_rows!=0){
								 if(mat[((m_rows - 1)*cols) + m_cols] == 1){
									 cont++;
								 }
								 if(mat[((m_rows - 1)*cols) + (m_cols + 1)] == 1){
									 cont++;
								 }
								 if(mat[((m_rows - 1)*cols) + (m_cols - 1)] == 1){
									 cont++;
								 }
							 }
							 if(m_cols!=0){
								 if(mat[(m_rows*cols) + (m_cols - 1)] == 1){
									 cont++;
								 }
							 }
							 if(m_rows < rows - 1){
								 if(mat[((m_rows + 1)*cols) + m_cols] == 1){
									 cont++;
								 }
								 if(mat[((m_rows + 1)*cols) + (m_cols - 1)] == 1){
									 cont++;
								 }
								 if(mat[((m_rows + 1)*cols) + (m_cols + 1)] == 1){
									 cont++;
								 }
							 }
							 if(m_cols < cols - 1){
								 if(mat[(m_rows*cols) + (m_cols + 1)] == 1){
									 cont++;
								 }
							 }*/
							 if(cell == 1){

								 if(cont < 2 || cont > 3){
									 return 0;
								 }
								 else{
									 return 1;
								 }
							 }
							 else{
								 if(cont == 3){
									 return 1;
								 }
								 else{
									 return 0;
								 }
							 }
							 //#endif
}

void gosper_setup(global int * mat, int rows, int cols, int c, int r){
	if(r == 1 && c == 25){
		mat[r*cols + c] = 1;
	}
	else if(r == 2 && (c == 25 || c == 23)){
		mat[r*cols + c] = 1;
	}
	else if(r == 3 && (c == 13 || c == 14 || c == 21 || c == 22 || c == 35 || c == 36)){
		mat[r*cols + c] = 1;
	}
	else if(r == 4 && (c == 12 || c == 16 || c == 21 || c == 22 || c == 35 || c == 36)){
		mat[r*cols + c] = 1;
	}
	else if(r == 5 && (c == 1 || c == 2 || c == 11 || c == 17 || c == 21 || c == 22)){
		mat[r*cols + c] = 1;
	}
	else if(r == 6 && (c == 1 || c == 2 || c == 11 || c == 15 || c == 17 || c == 18 || c == 23 || c == 25)){
		mat[r*cols + c] = 1;
	}
	else if(r == 7 && (c == 11 || c == 17 || c == 25)){
		mat[r*cols + c] = 1;
	}
	else if(r == 8 && (c == 12 || c == 16)){
		mat[r*cols + c] = 1;
	}
	else if(r == 9 && (c == 13 || c == 14)){
		mat[r*cols + c] = 1;
	}
	else{
		mat[r*cols + c] = 0;
	}
}

void diehard_setup(global int * mat, int rows, int cols, int c, int r){
	if(r == (((rows - 1) / 2) - 3) + 1 && c == (((cols - 1) / 2) - 5) + 7){
		mat[r*cols + c] = 1;
	}
	else if(r == (((rows - 1) / 2) - 3) + 3 && (c == (((cols - 1) / 2) - 5) + 2 || (c > (((cols - 1) / 2) - 5) + 5 && c < (((cols - 1) / 2) - 5) + 9))){
		mat[r*cols + c] = 1;
	}
	else if(r == (((rows - 1) / 2) - 3) + 2 && (c == (((cols - 1) / 2) - 5) + 1 || c == (((cols - 1) / 2) - 5) + 2)){
		mat[r*cols + c] = 1;
	}
	else{
		mat[r*cols + c] = 0;
	}
}

void acorn_setup(global int * mat, int rows, int cols, int c, int r){
	if(r == (((rows - 1) / 2) - 3) + 1 && c == (((cols - 1) / 2) - 5) + 2){
		mat[r*cols + c] = 1;
	}
	else if(r == (((rows - 1) / 2) - 3) + 2 && c == (((cols - 1) / 2) - 5) + 4){
		mat[r*cols + c] = 1;
	}
	else if(r == (((rows - 1) / 2) - 3) + 3 && ((c > (((cols - 1) / 2) - 5)) && (c < (((cols - 1) / 2) - 5) + 3))){
		mat[r*cols + c] = 1;
	}
	else if(r == (((rows - 1) / 2) - 3) + 3 && ((c > (((cols - 1) / 2) - 5) + 4) && (c < (((cols - 1) / 2) - 5) + 8))){
		mat[r*cols + c] = 1;
	}
	else{
		mat[r*cols + c] = 0;
	}
}

kernel void init(global int * mat, int rows, int cols, char init)
{
	// primo indice => colonne
	int c = get_global_id(0);
	// secondo indice => righe
	int r = get_global_id(1);
	if (r < rows && c < cols){
		if(init == 'd'){
			diehard_setup(mat, rows, cols, c, r);
		}
		else if(init == 'g'){
			gosper_setup(mat, rows, cols, c, r);
		}
		else if(init == 'a'){
			acorn_setup(mat, rows, cols, c, r);
		}
		else if(init == '1'){
			gosper_setup(mat, rows, cols, c, r);
		}
		else if(init == '2'){
			gosper_setup(mat, rows, cols, c, r);
		}
		else if(init == '3'){
			gosper_setup(mat, rows, cols, c, r);
		}
	}
}

kernel void generation(
	global int * restrict dst, /* matrice destinazione */
	global const int * restrict src, /* matrice sorgente */
	// righe e colonne della matrice src
	int rows, int cols)
	{
		const int c = get_global_id(0);
		const int r = get_global_id(1);

		if (r < rows && c < cols)
			dst[r*cols + c] = set_cell(src, rows, cols, c, r, src[r*cols + c]);
		return;
	}
